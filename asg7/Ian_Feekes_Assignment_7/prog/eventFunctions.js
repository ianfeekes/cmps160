/*Ian Feekes
 *#1474914
 *ifeekes@ucsc.edu
 *cmps160 asg7
 *eventFunctions.js
 *
 *This file has been altered significantly from the previous assignment. 
 *Mostly used for dealing with initializing the functionality of html 
 *elements, allong with generating an array of tilted cubes for a maze  
 */ 

 let zoomSlider;          //Responsible for holding camera zoom value 
 let speedSlider;         //Responsible for user camera movement speed 
 let rotSlider;           //Responsible for user camera rotation speed 
 let nearSlider;          //Near values
 let farSlider;           //Far values 
 let aSlider; 
 let orthoButton;         //Button toggler for orthogonal viewing
 let perButton;           //Button toggler for perspective viewing 
 let perspective=true;    //Perspective toggler initialization
 let absX, absY;          //For use in camera position movement 
 let normS=true;          //Boolean flag telling us whether or not to use the normal shader in tick/render
 let lX, lY, lZ;          //x y z coordinates of white light cube 
 let textBox;             //This is where game script is sent to the user via html 
 let strArr;              //array of scripting strings as the player iterates through 
 let moveFlag;            //flag for restricting user movement if necessary 
 let idx; 
 let prevIdx; 
 let lightCube;           //temporarily made global 
 let lr, lg, lb;          //global lighting variables generated by the glow stick 
 let baseCube;            //The base cube is made global for use in telling if the user is out of bounds 
 let cubes;               //contains all the important cubes for collission and for user interaction purposes 
 let gToggle=true; 
 let playerMarks;       //the number of cubes the player is allowed to mark throughout the maze

/*Initiallizes a few sliders, goes through my attempt to procedurally generate the world*/ 
function initEventHandelers() {
  textBox = document.getElementById("textBox"); 
  idx=0; 
  moveFlag=0;         //Initially the user must pick his glowstick before moving 
  strArr = [
    "Welcome to the virtual rave maze. Before you move, please \n select your most important tool - the color of your glowstick. \n Toggle colours by clicking on the stick directly in front of you , then press enter to confirm your selection. \n", 
    "Thats a groovy colour! Now you must make it through the maze to find the venue!", 
    "Yay you made it to the venue! Rage on!", 
    "Help: To move, use keys wsad, to rotate use keys j and l. Pressing 'u' will toggle holding out your glowstick. Pressing 'i' looking from the corner towards a block will mark the block so that you know you've been there (as well as amp up the intensity of the rave), but be careful: you only get to mark 5 blocks with your good vibes! The help message is toggled with the h key.",
    "Bad vibes, man! You fell into a lava lamp... try to make it next time by reloading the page", 
  ];
  playerMarks=5; 
  //cubes is initially empty 
  cubes=[]; 
  //Initialize the scene we are working with 
  currScene = new Scene();
  //This adds the light cube which is white 
  lX=1.1; 
  lY=-3.2; 
  lZ=0; 
  let white =[1,1,1];
  lightCube = new Lcube(.03, lX,lY, lZ); 
  lightCube.setColor(white); 
  currScene.addGeometry(lightCube); 

  //This adds the main world cube which is set to a sickening purple
  let mag = [.5,0.0,1.0]; 
  //Change this back to 1.0,true later 
  baseCube = new Cube(4,0,0,true); 
  baseCube.setColor(mag); 
  currScene.addGeometry(baseCube);
    /*Loops through x and y coordinates representing where to generate grid cubes*/ 
    for(let i = 0; i < 22; i++) 
    {
      for(let j = 0; j < 16; j++) 
      {
        /*Logic determining where we want to initialize our grid cubes to give the world
          a somewhat maze-like appearence */ 
        if(map1[j][i]==1)
        {
          /*Create the grid cube and add it to geometry*/ 
         
          let gridCube = new Cube(.1, -.9+(j*.2), .9-(i*.2), false); 
          //throw the gridcubes into a separate array additionally 
          cubes.push(gridCube); 
          currScene.addGeometry(gridCube); 
        }
        else if(map1[j][i]==2)
        {
          let rainCube = new Rcube(.1, -.9+(j*.2), .9-(i*.2), false); 
          cubes.push(rainCube); 
          currScene.addGeometry(rainCube); 
        }
      }
    }
    //Initializes the key listener functionality for processing which key was pressed 
    document.onkeydown = function(ev) { 
     processKey(ev); 
    };

    /*if we are still in the initial script for glowstick selection then allow the 
      glowstick to toggle through colours on mouseclicked*/ 
      canvas.onmousedown = function(ev){
        if(!moveFlag && bounded(ev))
          { 
            //sets the global lighting variables to randomly generated numbers 
            lr=Math.random();
            lg=Math.random(); 
            lb=Math.random(); 
            lightCube.setColor([lr, lg, lb]); 
            gl.uniform3f(u_LightColor, lr, lg, lb);
          }
      };

    //Start up the animation clock 
    tick();
}

/*This function handles mouse collision for the light cube initially when togglign colours. 
  If the cube shape is changed to be cylindrical then the logic will probably be a litle more 
  annoying to deal with*/ 
function bounded(ev)
{
  /*Gets the mousex and mousey coordinates, calibrates them based on a window of any given size, 
    and tests to see if they are within the lightCubes bounds for the initial rave light picking*/ 
  var x = ev.clientX;    
  var y = ev.clientY; 
  var rect = ev.target.getBoundingClientRect();
  x = (x-rect.left-(window.innerWidth-150)/2)/((window.innerWidth)*1.8);
  x*=.8;
  x+=g_EyeX;  
  y = ((window.innerHeight-100)/2 - (y - rect.top))/(window.innerHeight+200)/2;
  /*console.log(x+", "+y);
  console.log(lightCube.centerX-lightCube.size); 
  console.log(lightCube.centerX+lightCube.size); 
  console.log(lightCube.centerZ+lightCube.size); 
  console.log(lightCube.centerZ+lightCube.size);  

  console.log(x>lightCube.centerX-lightCube.size);
  console.log(x<lightCube.centerX+lightCube.size);*/ 
  //console.log(y<lightCube.centerZ+lightCube.size);
  //console.log(y<lightCube.centerZ+lightCube.size); 


  return((x>lightCube.centerX-lightCube.size)&&(x<lightCube.centerX+lightCube.size)
       &&(y<lightCube.centerZ+lightCube.size)&&(y<lightCube.centerZ+lightCube.size)); 
}

/*Processes camera movement on key events*/ 
function processKey(ev) {
  absX = Math.abs(G_atX);
  absY = Math.abs(G_atY);
  var rightAngle = (angleRotation - 90);
  var leftAngle = (angleRotation + 90);
  if(Math.sign(rightAngle) == -1) { rightAngle += 360; }
  if(Math.sign(leftAngle)== -1) {leftAngle+=360;}
  if(leftAngle >= 360) { leftAngle -= 360; }
  //Movement is only allowed if the user has selected his glowstick 
  if(moveFlag)
  {
  if(ev.keyCode == 68 || ev.keyCode == 39) goRight(rightAngle); 
  else if(ev.keyCode == 65 || ev.keyCode == 37)goLeft(leftAngle)
  else if(ev.keyCode == 87 || ev.keyCode == 38)goForward(); 
  else if(ev.keyCode == 83 || ev.keyCode == 40)goBackward(); 
  else if(ev.keyCode == 74)leftRotate(); 
  else if(ev.keyCode == 76)rightRotate();
  //If the user presses the 'i' key it will mark the block 
  else if(ev.keyCode == 73)markBlock(); 
  //The user can choose to take away or bring back his glowstick by pressing 'u'
  else if(ev.keyCode == 85)toggleGlowstick(); 
  }
  //enter makes it so that the colour sticks and that the user can start moving 
  if(ev.keyCode==13 && !moveFlag){
    idx++;  
    moveFlag=true; 
  }
  //'h' key event toggles the help message 
  else if(ev.keyCode == 72 )
    {
      if(idx!=3){prevIdx=idx;idx=3;}
      else idx=prevIdx; 
    }
}

/*To fulfill colour-based picking and to mark where you've been in the maze so that
 *this game doesn't quickly become hellish, the mark block function allows the user 
 *to press the 'i' key and the block in the center of the screen will change colour*/ 
function markBlock()
{
  if(playerMarks<=0)return; 
  //playerMarks--;
  let arr=findAdjCubes(); 

  for(let i=0;i<arr.length;i++)
  {
    if(centered(arr[i])&& arr[i].getColor()!=[0,1.0,1.0])
    {
     playerMarks--; 
     arr[i].setColor([0,1.0,1.0]);
     //aFluc-=1; 
     rate+=.03 
     break; 
    }
  }
}

/*Determines if a cube is pointed to at the center of the screen*/ 
function centered(cube)
{
  //console.log(G_atX+", "+g_EyeX); 
  if(Math.abs(G_atX)<45)
  {
    //console.log("forward");
    if(Math.abs(cube.centerX-G_atX)>.4)return false; 
    else return true; 
  } 
  if(G_atX-g_EyeX>=0)
  {
    //facing quadrant 1
   if(G_atY-g_EyeY>=0)
    {
      if(cube.centerX>=g_EyeX && cube.centerY>=g_EyeY)
        return true; 
    }
    //facing quadrant 2
    else
    {
      //if(Math.abs(cube.centerX-g_EyeX)>.2)return false; 

      if(cube.centerX>=g_EyeX && cube.centerY<=g_EyeY)
        return true; 
    }
  }
  else
  {
    //facing quadrant 3 
    if(G_atY-g_EyeY>=0)
    {
      if(cube.centerX<=g_EyeX && cube.centerY>=g_EyeY)
        return true; 
    }
    //facing quadrant 4 
    else
    {
      //if(Math.abs(cube.centerX-g_EyeX)>.2)return false; 

      if(cube.centerX<=g_EyeX && cube.centerY<=g_EyeY)
        return true; 
    }
  }
  return false; 

}

/*Takes in the hypothetical x and y values and sees if there will be collision. If not, then it 
  allows for movement. This function is called each time the user wants to move the camera*/ 
function freeMove(x, y)
{
  /*figures out the array of adjacent cubes so that we only need to detect collision for the nearest 
    few objects
    */ 
  let a=findAdjCubes(); 
  //iterate through all nearby cubes and look to see if there is collision 
  for(let i=0;i<a.length;i++)
  {
    /*if the hypothetical camera position would put it within bounds of a cube then stop that from 
      happening */ 
     if(x+.05>a[i].centerX-a[i].size && x-.05<a[i].centerX+a[i].size &&
        y+.05>a[i].centerY-a[i].size && y-.05<a[i].centerY+a[i].size) return false; 
      //For my original debugging with collision I would set the cubes to white to tell when you collide 
      //{a[i].setColor([1,1,1]);return false; }

  }
  //if there's no collision with the nearby cubes then all is good 
  return true; 
}

/*Makes it so that we don't have to iterate through an array of hundreds of data 
  structures each time the user presses a key to save on runtime */ 
function findAdjCubes()
{
  let arr=[]; 
  for(let i=0;i<cubes.length;i++)
  {
    if(Math.abs(cubes[i].centerX-g_EyeX)<.3 && Math.abs(cubes[i].centerY-g_EyeY)<.3)
      {
        arr.push(cubes[i]);
        //cubes[i].setColor([0,1,1]); 
      } 
  }
  return arr; 
}

/*This allows it so that the glowstick can stop annoying you while you're navigating the 
  maze, and so that lighting can be slightly controlled by the user in interesting ways. */ 
function toggleGlowstick()
{
  gToggle=!gToggle; 
}

/*This is called whenever N is pressed to reset the value of N to true so that the user 
 *can see the differences in lighting*/ 

function goBackward()
{
  let backVal = 45/1000; 
  if(Math.sign(G_atX) == -1 && Math.sign(G_atY) == 1) {
      if(absX > absY && freeMove(g_EyeX+backVal, g_EyeY-backVal*(absY/absX))) {
        g_EyeY -= backVal* (absY/absX);
        g_EyeX += backVal;
        //lightCube.move(backVal, -backVal*(absY/absX)); 
      } else if(freeMove(g_EyeX+backVal*(absX/absY), g_EyeY-backVal)) {
        g_EyeY -= backVal;
        g_EyeX += backVal * (absX/absY);
        //lightCube.move(backVal*(absX/absY),-backVal,);
      } 
    } else if(Math.sign(G_atX) == -1 && Math.sign(G_atY) == -1){             
      if(absX > absY && freeMove(g_EyeX+backVal, g_EyeY+backVal*(absY/absX))) {
        g_EyeY += backVal * (absY/absX);
        g_EyeX += backVal;
        //lightCube.move(backVal, backVal*(absY/absX)); 
      } else if(freeMove(g_EyeX+backVal*(absX/absY), g_EyeY+backVal)) {
        g_EyeY += backVal;
        g_EyeX += backVal * (absX/absY);
        //lightCube.move(backVal*(absX/absY),backVal); 
      } 
    } else if (Math.sign(G_atX) == 1 && Math.sign(G_atY) == -1) {
      if(absX > absY && freeMove(g_EyeX-backVal, g_EyeY+backVal*(absY/absX))) {
        g_EyeY += backVal * (absY/absX);
        g_EyeX -= backVal;
        //lightCube.move(-backVal, backVal*(absY/absX)); 
      } else if(freeMove(g_EyeX-backVal*(absX/absY), g_EyeY+backVal)) {
        g_EyeY += backVal;
        g_EyeX -= backVal * (absX/absY);
        //lightCube.move(-backVal*(absX/absY), backVal); 
      } 
    } else {
      if(absX > absY && freeMove(g_EyeX-backVal, g_EyeY-backVal*(absY/absX))) {
        g_EyeY -= backVal * (absY/absX);
        g_EyeX -= backVal;
        //lightCube.move(-backVal, -backVal*(absY/absX)); 
      } else if(freeMove(g_EyeX-backVal*(absX/absY), g_EyeY-backVal)){
        g_EyeY -= backVal;
        g_EyeX -= backVal * (absX/absY);
        //lightCube.move(-backVal*(absX/absY), -backVal); 
      } 
    }
}

//now detects using freeMove to see if movement is possible 
function goForward()
{
  let forVal = 45/1000; 
  if(Math.sign(G_atX) == -1 && Math.sign(G_atY) == 1) { 
      if(absX > absY && freeMove(g_EyeX-forVal, g_EyeY+forVal*(absY/absX))) {
        g_EyeY += forVal * (absY/absX);
        g_EyeX -= forVal;
        //lightCube.move(-forVal, forVal*(absY/absX)); 
      } else if(freeMove(g_EyeX-forVal*(absX/absY), g_EyeY+forVal)){
        g_EyeY += forVal;
        g_EyeX -= forVal * (absX/absY);
        //lightCube.move(-forVal*(absX/absY), forVal); 
      } 
    } else if(Math.sign(G_atX) == -1 && Math.sign(G_atY) == -1){                
      if(absX > absY && freeMove(g_EyeX-forVal, g_EyeY-forVal*(absY/absX))) {
        g_EyeY -= forVal * (absY/absX);
        g_EyeX -= forVal;
        //lightCube.move(-forVal, -forVal*(absY/absX)); 
      } else if(freeMove(g_EyeX-forVal*(absX/absY), g_EyeY-forVal)){
        g_EyeY -= forVal;
        g_EyeX -= forVal * (absX/absY);
        //lightCube.move(-forVal*(absX/absY), -forVal); 
      } 
    } else if (Math.sign(G_atX) == 1 && Math.sign(G_atY) == -1) {
      if(absX > absY && freeMove(g_EyeX+forVal, g_EyeY-forVal*(absY/absX))) {
        g_EyeY -= forVal * (absY/absX);
        g_EyeX += forVal;
        //lightCube.move(forVal, -forVal*(absY/absX)); 
      } else if(freeMove(g_EyeX+forVal*(absX/absY),g_EyeY-forVal)) {
        g_EyeY -= forVal;
        g_EyeX += forVal * (absX/absY);
        //lightCube.move(forVal*(absX/absY), -forVal); 
      } 
    } else {
      if(absX > absY && freeMove(g_EyeX+forVal, g_EyeY+forVal*(absY/absX))) {
        g_EyeY += forVal * (absY/absX);
        g_EyeX += forVal;
        //lightCube.move(forVal, forVal*(absY/absX)); 
      } else if(freeMove(g_EyeX+forVal*(absX/absY), g_EyeY+forVal)){
        g_EyeY += forVal;
        g_EyeX += forVal * (absX/absY);
        //lightCube.move(forVal*(absX/absY), forVal); 
      } 
    } 
}

function goRight(leftAngle)
{
  let lVal = 45/1000; 
  if(leftAngle <45 && freeMove(g_EyeX+lVal, g_EyeY+lVal*(absX/absY)))
  {
    g_EyeY +=lVal*(absX/absY); 
    g_EyeX += lVal;
    //lightCube.move(lVal, lVal*(absX/absY)); 
  }
  else if(leftAngle<90 && freeMove(g_EyeX+lVal*(absY/absX), g_EyeY+lVal))
  {
    g_EyeY += lVal;
    g_EyeX += lVal * (absY/absX);
    //lightCube.move(lVal*(absY/absX), lVal); 
  }
  else if(leftAngle<135 && freeMove(g_EyeX-lVal*(absY/absX), g_EyeY+lVal))
  {
    g_EyeY += lVal;
    g_EyeX -= lVal * (absY/absX);
    //lightCube.move(-lVal*(absY/absX), lVal); 
  }
  else if(leftAngle<180 && freeMove(g_EyeX-lVal, g_EyeY+lVal*(absX/absY)))
  {
    g_EyeY += lVal * (absX/absY);
    g_EyeX -= lVal;
    //lightCube.move(-lVal, lVal*(absX/absY)); 
  }
  else if(leftAngle<225 && freeMove(g_EyeX-lVal, g_EyeY-lVal*(absX/absY)))
  {
    g_EyeY -= lVal * (absX/absY);
    g_EyeX -= lVal;
    //lightCube.move(-lVal, -lVal*(absX/absY)); 
  }
  else if(leftAngle<270 && freeMove(g_EyeX-lVal, g_EyeY-lVal*(absX/absY)))
  {
    g_EyeY -= lVal * (absX/absY);
    g_EyeX -= lVal;
    //lightCube.move(-lVal, -lVal*(absX/absY)); 
  }
  else if(leftAngle<315 && freeMove(g_EyeX+lVal*(absY/absX), g_EyeY-lVal))
  {
    g_EyeY -= lVal;
    g_EyeX += lVal * (absY/absX);
    //lightCube.move(lVal*(absY/absX), -lVal); 
  }
  else if(freeMove(g_EyeX+lVal, g_EyeY-lVal*(absX/absY)))
  {
    g_EyeY -= lVal * (absX/absY);
    g_EyeX += lVal;
    //lightCube.move(lVal, -lVal*(absX/absY)); 
  } 
}

/*Processes the angle for how to increment the camera*/ 
function goLeft(leftAngle)
{
  let lVal = 45/1000; 
  if(leftAngle <45 && freeMove(g_EyeX+lVal, g_EyeY+lVal*(absX/absY)))
  {
    g_EyeY+=lVal*(absX/absY); 
    g_EyeX += lVal;
    //lightCube.move(lVal, lVal*(absX/absY)); 
  }
  else if(leftAngle<90 && freeMove(g_EyeX+lVal*(absY/absX), g_EyeY+lVal))
  {
    g_EyeY += lVal;
    g_EyeX += lVal * (absY/absX);
    //lightCube.move(lVal*(absY/absX), lVal); 
  }
  else if(leftAngle<135 && freeMove(g_EyeX-lVal*(absY/absX), g_EyeY+lVal))
  {
    g_EyeY += lVal;
    g_EyeX -= lVal * (absY/absX);
    //lightCube.move(-lVal*(absY/absX), lVal); 
  }
  else if(leftAngle<180 && freeMove(g_EyeX-lVal, g_EyeY+lVal*(absX/absY)))
  {
    g_EyeY += lVal * (absX/absY);
    g_EyeX -= lVal;
    //lightCube.move(-lVal, lVal*(absX/absY)); 
  }
  else if(leftAngle<225 && freeMove(g_EyeX-lVal, g_EyeY-lVal*(absX/absY)))
  {
    g_EyeY -= lVal * (absX/absY);
    g_EyeX -= lVal;
    //lightCube.move(-lVal, -lVal*(absX/absY)); 
  }
  else if(leftAngle<270 && freeMove(g_EyeX-lVal, g_EyeY-lVal*(absX/absY)))
  {
    g_EyeY -= lVal * (absX/absY);
    g_EyeX -= lVal;
    //lightCube.move(-lVal*(absX/absY), -lVal); 
  }
  else if(leftAngle<315 && freeMove(g_EyeX+lVal*(absY/absX), g_EyeY-lVal))
  {
    g_EyeY -= lVal;
    g_EyeX += lVal * (absY/absX);
    //lightCube.move(lVal*(absY/absX), -lVal); 
  }
  else if(freeMove(g_EyeX+lVal, g_EyeY-lVal*(absX/absY)))
  {
    g_EyeY -= lVal * (absX/absY);
    g_EyeX += lVal;
    //lightCube.move(lVal, -lVal*(absX/absY)); 
  } 
}

function leftRotate()
{ 
    console.log(G_atX-g_EyeX); 
    console.log(G_atY-g_EyeY); 
    let rotIncr = 10; 
   // console.log(rotIncr);
    angleRotation += rotIncr;
    angleRotation%=360;
    /*if(G_atX-g_EyeX>0 && 100*Math.cos(angleRotation*(Math.PI/180))<=0)
    {
      console.log("moving cube for new perspective forward"); 
    }
    else*//* if(G_atX<=0 && 100*Math.cos(angleRotation*(Math.PI/180))>0)
    {
      //console.log("moving cube for new perspective back "); 
      lightCube.move(.3, 0); 
    }
    else if(G_atX>0 && 100*Math.cos(angleRotation*(Math.PI/180))<=0)
    {
      //console.log("Moving cube for new perspective forward"); 
      lightCube.move(-.3, 0); 
    }
    
    if(G_atY>0 && 100*Math.sin(angleRotation*(Math.PI/180))<=0)
    {
      //console.log("moving cube for new perspective left side  "); 
      lightCube.move(0, -.4); 
    }
    else if(G_atY<=0 && 100*Math.sin(angleRotation*(Math.PI/180))>0)
    {
      lightCube.move(0, .4); 
      //console.log("moving the cube for new perspective right side"); 
    }*/ 

    G_atX = 100 * Math.cos(angleRotation*(Math.PI/180));
    G_atY = 100 * Math.sin(angleRotation*(Math.PI/180));


   /* console.log(angleRotation); 
    console.log(Math.cos(angleRotation*(Math.PI/180))/20);
    console.log(Math.sin(angleRotation*(Math.PI/180))/20); 
    lightCube.move(Math.cos(angleRotation*(Math.PI/180))/10, Math.sin(angleRotation*(Math.PI/180))/10);*/ 
    //lightCube.move(G_atX, G_atY);
    //lightCube.rotate(rotIncr); 
}

function rightRotate()
 {
    let rotIncr = 10; 
    //console.log(rotIncr); 
    angleRotation -= rotIncr;
    angleRotation %=360;
    G_atX = 100 * Math.cos(angleRotation*(Math.PI/180));
    G_atY = 100 * Math.sin(angleRotation*(Math.PI/180));
    /*console.log(angleRotation); 
    console.log(Math.cos(angleRotation*(Math.PI/180))/20);
    console.log(Math.sin(angleRotation*(Math.PI/180))/20); 
    lightCube.move(Math.cos(angleRotation*(Math.PI/180))/10, Math.sin(angleRotation*(Math.PI/180))/10);*/ 
    //lightCube.rotate(-rotIncr); 
  }

/*Resets the canvas' width and height to default values as specified on 
  the canvas initialization in main, and then calls reload*/ 
function resize() {
  canvas.width=window.innerWidth-200; 
  canvas.height=window.innerHeight-100; 
  window.location.reload(); 
}

/*Returns true if the user has gone out of the region of the world's base cube, in which case it's game over*/ 
function outOfBounds(){
  return (g_EyeX>baseCube.centerX+baseCube.size || g_EyeX<baseCube.centerX-baseCube.size
      ||  g_EyeY>baseCube.centerY+baseCube.size || g_EyeY<baseCube.centerY-baseCube.size); 
}


