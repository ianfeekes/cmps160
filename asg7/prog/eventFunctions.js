/*Ian Feekes
 *#1474914
 *ifeekes@ucsc.edu
 *cmps160 asg5
 *eventFunctions.js
 *
 *This file has been altered significantly from the previous assignment. 
 *Mostly used for dealing with initializing the functionality of html 
 *elements, allong with generating an array of tilted cubes for a maze  
 */ 

 let zoomSlider;          //Responsible for holding camera zoom value 
 let speedSlider;         //Responsible for user camera movement speed 
 let rotSlider;           //Responsible for user camera rotation speed 
 let nearSlider;          //Near values
 let farSlider;           //Far values 
 let aSlider; 
 let orthoButton;         //Button toggler for orthogonal viewing
 let perButton;           //Button toggler for perspective viewing 
 let perspective=true;    //Perspective toggler initialization
 let absX, absY;          //For use in camera position movement 
 let normS=true;          //Boolean flag telling us whether or not to use the normal shader in tick/render
 let lX, lY, lZ;          //x y z coordinates of white light cube 
 let textBox;             //This is where game script is sent to the user via html 
 let strArr;              //array of scripting strings as the player iterates through 
 let moveFlag;            //flag for restricting user movement if necessary 
 let idx; 
 let prevIdx; 
 let lightCube;           //temporarily made global 
 let lr, lg, lb;          //global lighting variables generated by the glow stick 

/*Initiallizes a few sliders, goes through my attempt to procedurally generate the world*/ 
function initEventHandelers() {
  textBox = document.getElementById("textBox"); 
  idx=0; 
  moveFlag=0;         //Initially the user must pick his glowstick before moving 
  strArr = [
    "Welcome to the virtual rave maze. Before you move, please \n select your most important tool - the color of your glowstick. \n Toggle colours by clicking, then press enter to confirm your selection. \n", 
    "Thats a groovy colour! Now you must make it through the maze to find the venue!", 
    "dummy string for now...", 
    "Help: To move, use keys wsad, to rotate use keys j and l. The help message is toggled with the h key.",
  ];
  //Initialize the scene we are working with 
  currScene = new Scene();
  //This adds the light cube which is white 
  lX=0; 
  lY=-.3; 
  lZ=0; 
  let white =[1,1,1];
  lightCube = new Lcube(.03, lX,lY, lZ); 
  lightCube.setColor(white); 
  currScene.addGeometry(lightCube); 

  //This adds the main world cube which is set to a sickening purple
  let mag = [.5,0.0,1.0]; 
  //Change this back to 1.0,true later 
  let baseCube = new Cube(1.0,0,0,true); 
  baseCube.setColor(mag); 
  currScene.addGeometry(baseCube);
    /*Loops through x and y coordinates representing where to generate grid cubes*/ 
    for(let i = 0; i < 10; i++) 
    {
      for(let j = 0; j < 10; j++) 
      {
        /*Logic determining where we want to initialize our grid cubes to give the world
          a somewhat maze-like appearence */ 
        if(map1[j][i]==1)
        {
          /*Create the grid cube and add it to geometry*/ 
         
          let gridCube = new Cube(.1, -.9+(j*.2), .9-(i*.2), false); 

          currScene.addGeometry(gridCube); 
        }
      }
    }
    //Initializes the key listener functionality for processing which key was pressed 
    document.onkeydown = function(ev) { 
     processKey(ev); 
    };

    /*if we are still in the initial script for glowstick selection then allow the 
      glowstick to toggle through colours on mouseclicked*/ 
      canvas.onmousedown = function(ev){
        if(!moveFlag)
          { 
            //sets the global lighting variables to randomly generated numbers 
            lr=Math.random();
            lg=Math.random(); 
            lb=Math.random(); 
            lightCube.setColor([lr, lg, lb]); 
            gl.uniform3f(u_LightColor, lr, lg, lb);
          }
      };

    //Start up the animation clock 
    tick();
}

/*Processes camera movement on key events*/ 
function processKey(ev) {
  absX = Math.abs(G_atX);
  absY = Math.abs(G_atY);
  var rightAngle = (angleRotation - 90);
  var leftAngle = (angleRotation + 90);
  if(Math.sign(rightAngle) == -1) { rightAngle += 360; }
  if(Math.sign(leftAngle)== -1) {leftAngle+=360;}
  if(leftAngle >= 360) { leftAngle -= 360; }
  if(moveFlag)
  {
  if(ev.keyCode == 68 || ev.keyCode == 39) goRight(rightAngle); 
  else if(ev.keyCode == 65 || ev.keyCode == 37)goLeft(leftAngle)
  else if(ev.keyCode == 87 || ev.keyCode == 38)goForward(); 
  else if(ev.keyCode == 83 || ev.keyCode == 40)goBackward(); 
  else if(ev.keyCode == 74)leftRotate(); 
  else if(ev.keyCode == 76)rightRotate();
  }
  //enter makes it so that the colour sticks and that the user can start moving 
  if(ev.keyCode==13 && !moveFlag){
    idx++;  
    moveFlag=true; 
  }
  //set to help message toggling 
  else if(ev.keyCode == 72 )
    {
      if(idx!=3){prevIdx=idx;idx=3;}
      else idx=prevIdx; 
    }
  else if(ev.keyCode == 78){normS=!normS;}
}

/*This is called whenever N is pressed to reset the value of N to true so that the user 
 *can see the differences in lighting*/ 

function goBackward()
{
  let backVal = 50/1000; 
  if(Math.sign(G_atX) == -1 && Math.sign(G_atY) == 1) {
      if(absX > absY) {
        g_EyeY -= backVal* (absY/absX);
        g_EyeX += backVal;
      } else {
        g_EyeY -= backVal;
        g_EyeX += backVal * (absX/absY);
      } 
    } else if(Math.sign(G_atX) == -1 && Math.sign(G_atY) == -1){             
      if(absX > absY) {
        g_EyeY += backVal * (absY/absX);
        g_EyeX += backVal;
      } else {
        g_EyeY += backVal;
        g_EyeX += backVal * (absX/absY);
      } 
    } else if (Math.sign(G_atX) == 1 && Math.sign(G_atY) == -1) {
      if(absX > absY) {
        g_EyeY += backVal * (absY/absX);
        g_EyeX -= backVal;
      } else {
        g_EyeY += backVal;
        g_EyeX -= backVal * (absX/absY);
      } 
    } else {
      if(absX > absY) {
        g_EyeY -= backVal * (absY/absX);
        g_EyeX -= backVal;
      } else {
        g_EyeY -= backVal;
        g_EyeX -= backVal * (absX/absY);
      } 
    }
}

function goForward()
{
  let forVal = 50/1000; 
  if(Math.sign(G_atX) == -1 && Math.sign(G_atY) == 1) { 
      if(absX > absY) {
        g_EyeY += forVal * (absY/absX);
        g_EyeX -= forVal;
      } else {
        g_EyeY += forVal;
        g_EyeX -= forVal * (absX/absY);
      } 
    } else if(Math.sign(G_atX) == -1 && Math.sign(G_atY) == -1){                
      if(absX > absY) {
        g_EyeY -= forVal * (absY/absX);
        g_EyeX -= forVal;
      } else {
        g_EyeY -= forVal;
        g_EyeX -= forVal * (absX/absY);
      } 
    } else if (Math.sign(G_atX) == 1 && Math.sign(G_atY) == -1) {
      if(absX > absY) {
        g_EyeY -= forVal * (absY/absX);
        g_EyeX += forVal;
      } else {
        g_EyeY -= forVal;
        g_EyeX += forVal * (absX/absY);
      } 
    } else {
      if(absX > absY) {
        g_EyeY += forVal * (absY/absX);
        g_EyeX += forVal;
      } else {
        g_EyeY += forVal;
        g_EyeX += forVal * (absX/absY);
      } 
    } 
}

function goRight(leftAngle)
{
  let lVal = 50/1000; 
  if(leftAngle <45)
  {
    g_EyeY+=lVal*(absX/absY); 
    g_EyeX += lVal;
  }
  else if(leftAngle<90)
  {
    g_EyeY += lVal;
    g_EyeX += lVal * (absY/absX);
  }
  else if(leftAngle<135)
  {
    g_EyeY += lVal;
    g_EyeX -= lVal * (absY/absX);
  }
  else if(leftAngle<180)
  {
    g_EyeY += lVal * (absX/absY);
    g_EyeX -= lVal;
  }
  else if(leftAngle<225)
  {
    g_EyeY -= lVal * (absX/absY);
    g_EyeX -= lVal;
  }
  else if(leftAngle<270)
  {
    g_EyeY -= lVal * (absX/absY);
    g_EyeX -= lVal;
  }
  else if(leftAngle<315)
  {
    g_EyeY -= lVal;
    g_EyeX += lVal * (absY/absX);
  }
  else 
  {
    g_EyeY -= lVal * (absX/absY);
    g_EyeX += lVal;
  } 
}

/*Processes the angle for how to increment the camera*/ 
function goLeft(leftAngle)
{
  //console.log(leftAngle); 
  /* let lVal = speedSlider.value/1000; 
  if(Math.sin(leftAngle)>0)
  {
    g_EyeY+=lVal*(absX/absY);
  }
  else g_EyeY-=lVal*(absX/absY); 
  if(Math.cos(leftAngle)>0)
  {
    g_EyeX+=lVal*(absX/absY);
  }
  else g_EyeX-=lVal*(absX/absY); */ 

  let lVal = 50/1000; 
  if(leftAngle <45)
  {
    g_EyeY+=lVal*(absX/absY); 
    g_EyeX += lVal;
  }
  else if(leftAngle<90)
  {
    g_EyeY += lVal;
    g_EyeX += lVal * (absY/absX);
  }
  else if(leftAngle<135)
  {
    g_EyeY += lVal;
    g_EyeX -= lVal * (absY/absX);
  }
  else if(leftAngle<180)
  {
    g_EyeY += lVal * (absX/absY);
    g_EyeX -= lVal;
  }
  else if(leftAngle<225)
  {
    g_EyeY -= lVal * (absX/absY);
    g_EyeX -= lVal;
  }
  else if(leftAngle<270)
  {
    g_EyeY -= lVal * (absX/absY);
    g_EyeX -= lVal;
  }
  else if(leftAngle<315)
  {
    g_EyeY -= lVal;
    g_EyeX += lVal * (absY/absX);
  }
  else 
  {
    g_EyeY -= lVal * (absX/absY);
    g_EyeX += lVal;
  } 
}

function leftRotate()
{ 
    let rotIncr = 10; 
   // console.log(rotIncr);
    angleRotation += rotIncr;
    angleRotation%=360;
    G_atX = 100 * Math.cos(angleRotation*(Math.PI/180));
    G_atY = 100 * Math.sin(angleRotation*(Math.PI/180));
}

function rightRotate()
 {
    let rotIncr = 10; 
    //console.log(rotIncr); 
    angleRotation -= rotIncr;
    angleRotation %=360;
    G_atX = 100 * Math.cos(angleRotation*(Math.PI/180));
    G_atY = 100 * Math.sin(angleRotation*(Math.PI/180));
  }

/*Resets the canvas' width and height to default values as specified on 
  the canvas initialization in main, and then calls reload*/ 
function resize() {
  canvas.width=window.innerWidth-200; 
  canvas.height=window.innerHeight-100; 
  window.location.reload(); 
}


